package tudbut.mod.client.ttcp.mods.exploit;

import de.tudbut.type.Vector3d;
import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.Map;
import net.minecraft.block.Block;
import net.minecraft.block.BlockFalling;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntityChest;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;
import net.minecraft.world.WorldSettings;
import net.minecraft.world.WorldType;
import net.minecraft.world.storage.WorldInfo;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.Event;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import tudbut.mod.client.ttcp.TTCp;
import tudbut.mod.client.ttcp.gui.lib.component.Button;
import tudbut.mod.client.ttcp.utils.ChatUtils;
import tudbut.mod.client.ttcp.utils.Module;
import tudbut.mod.client.ttcp.utils.Tesselator;
import tudbut.mod.client.ttcp.utils.ThreadManager;
import tudbut.mod.client.ttcp.utils.WorldGeneratorV2;
import tudbut.mod.client.ttcp.utils.category.Exploit;
import tudbut.obj.Save;

@Exploit
public class SeedOverlay
extends Module {
    Map<BlockPos, Integer> toRender = new HashMap<BlockPos, Integer>();
    Map<BlockPos, Boolean> toRenderTiles = new HashMap<BlockPos, Boolean>();
    WorldGeneratorV2 generator;
    World world;
    String worldOptions;
    WorldType worldType;
    @Save
    long seed = Long.MAX_VALUE;
    boolean isUpdating = false;
    boolean lock = false;
    int renderType = 0;
    boolean mode = false;
    static final ArrayList<Block> disableCheck = new ArrayList();
    Vec3d pos;

    public SeedOverlay() {
        this.updateBinds();
        this.pos = new Vec3d(0.0, 0.0, 0.0);
    }

    @Override
    public void updateBinds() {
        this.subComponents.clear();
        this.subComponents.add(new Button("Update world data", it -> ThreadManager.run(() -> {
            this.world = TTCp.world;
            this.worldOptions = TTCp.world.getWorldInfo().getGeneratorOptions();
            this.worldType = TTCp.world.getWorldType();
            ChatUtils.print("Downloaded data, now generating chunks!");
            if (this.seed != Long.MAX_VALUE) {
                ThreadManager.run(() -> {
                    if (this.generator != null) {
                        try {
                            this.generator.stopServer();
                        }
                        catch (Exception exception) {
                            // empty catch block
                        }
                    }
                    this.generator = SeedOverlay.createFreshWorldCopy(this.world, this.seed);
                    this.world = this.generator.getWorld(TTCp.world.provider.getDimension());
                });
            } else {
                ChatUtils.print("Error: No seed given! ',seedoverlay <seed>' to set");
            }
        })));
        this.subComponents.add(new Button("Delete world data", it -> ThreadManager.run(() -> {
            this.world = null;
            this.generator.stopServer();
            this.generator = null;
        })));
        this.subComponents.add(new Button("Render type: " + (this.renderType == 0 ? "Box" : (this.renderType == 1 ? "Marker" : "Plane")), it -> {
            ++this.renderType;
            if (this.renderType > 2) {
                this.renderType = 0;
            }
            it.text = "Render type: " + (this.renderType == 0 ? "Box" : (this.renderType == 1 ? "Marker" : "Plane"));
        }));
        this.subComponents.add(new Button("Type: " + (!this.mode ? "SeedOverlay" : "GappleFinder"), it -> {
            this.mode = !this.mode;
            this.toRender.clear();
            it.text = "Type: " + (!this.mode ? "SeedOverlay" : "GappleFinder");
        }));
    }

    @Override
    public void onConfigLoad() {
        this.updateBinds();
    }

    private void updateSeedOverlay() {
        HashMap<BlockPos, Integer> toRender = new HashMap<BlockPos, Integer>();
        EntityPlayerSP player = TTCp.player;
        if (this.world != null) {
            this.world = this.generator.getWorld(TTCp.world.provider.getDimension());
            for (int z = -128; z < 128; ++z) {
                for (int x = -128; x < 128; ++x) {
                    int theX = (int)(player.field_70165_t + (double)x);
                    int theZ = (int)(player.field_70161_v + (double)z);
                    for (int y = 0; y < 256; ++y) {
                        BlockPos bp = new BlockPos(theX, y, theZ);
                        if (!TTCp.mc.world.func_175668_a(bp, false) || !this.world.getChunkFromBlockCoords(bp).isTerrainPopulated()) continue;
                        IBlockState a = TTCp.world.getBlockState(bp);
                        IBlockState b = this.world.getBlockState(bp);
                        if (!this.mode) {
                            if (a.func_185904_a().equals(b.func_185904_a()) || a.func_185904_a().isLiquid() || b.func_185904_a().isLiquid() || BlockFalling.class.isAssignableFrom(a.getBlock().getClass()) || BlockFalling.class.isAssignableFrom(b.getBlock().getClass()) || disableCheck.contains(a.getBlock()) || disableCheck.contains(b.getBlock())) continue;
                            if (this.renderType == 2) {
                                bp = new BlockPos(bp.func_177958_n(), 42, bp.func_177952_p());
                            }
                            if (a.func_185904_a() == Material.AIR) {
                                toRender.put(bp, -1);
                                continue;
                            }
                            if (b.func_185904_a() == Material.AIR) {
                                toRender.put(bp, 1);
                                continue;
                            }
                            toRender.put(bp, 0);
                            continue;
                        }
                        if (b.getBlock() != Blocks.CHEST) continue;
                        TileEntityChest chest = (TileEntityChest)this.world.getTileEntity(bp);
                        assert (chest != null);
                        if (chest.func_184276_b() == null) continue;
                        chest.func_184281_d(null);
                        boolean gap = false;
                        boolean egap = false;
                        for (int i = 0; i < 27; ++i) {
                            if (chest.func_70301_a(i).getItem() != Items.GOLDEN_APPLE) continue;
                            gap = true;
                            if (chest.func_70301_a(i).getMetadata() != 1) continue;
                            egap = true;
                        }
                        if (!gap) continue;
                        this.toRenderTiles.put(bp, egap);
                    }
                }
            }
        }
        this.lock = true;
        this.toRender = toRender;
        this.lock = false;
    }

    public static WorldGeneratorV2 createFreshWorldCopy(World worldIn, long seed) {
        WorldInfo i = worldIn.getWorldInfo();
        NBTTagCompound nbt = i.cloneNBTCompound(null);
        nbt.setLong("RandomSeed", seed);
        WorldSettings settings = new WorldSettings(seed, worldIn.getWorldInfo().getGameType(), true, false, worldIn.getWorldType());
        settings.setGeneratorOptions(worldIn.getWorldInfo().getGeneratorOptions());
        WorldGeneratorV2 w = WorldGeneratorV2.create(settings);
        w.startServerThread();
        while (!w.done) {
            ChatUtils.print(w.percentDone + "% Generated");
            try {
                Thread.sleep(1000L);
            }
            catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        ChatUtils.print("Done!");
        return w;
    }

    @Override
    public void onChat(String s, String[] args) {
        this.isUpdating = false;
        try {
            this.seed = Long.parseLong(s);
        }
        catch (NumberFormatException e) {
            this.seed = s.hashCode();
        }
        ChatUtils.print("Set! " + this.seed);
    }

    @Override
    public void onTick() {
        if (this.isUpdating) {
            return;
        }
        this.isUpdating = true;
        ThreadManager.run(() -> {
            try {
                this.updateSeedOverlay();
            }
            catch (Throwable e) {
                e.printStackTrace();
            }
            this.isUpdating = false;
        });
    }

    @SubscribeEvent
    public void onRenderWorld(Event event) {
        block17: {
            if (!(event instanceof RenderWorldLastEvent) || !this.enabled || !TTCp.isIngame()) break block17;
            Entity e = TTCp.mc.getRenderViewEntity();
            assert (e != null);
            this.pos = e.getPositionEyes(((RenderWorldLastEvent)event).getPartialTicks()).addVector(0.0, (double)(-e.getEyeHeight()), 0.0);
            while (this.lock) {
            }
            if (!this.mode) {
                Map<BlockPos, Integer> toRender = this.toRender;
                BlockPos[] toRenderPositions = this.toRender.keySet().toArray(new BlockPos[0]);
                if (toRenderPositions.length > 50000) {
                    ChatUtils.print("Too many blocks to render!");
                    return;
                }
                for (int i = 0; i < toRenderPositions.length; ++i) {
                    int color = toRender.get(toRenderPositions[i]);
                    switch (color) {
                        case 1: {
                            color = 0x4000FF00;
                            break;
                        }
                        case 0: {
                            color = 0x40808000;
                            break;
                        }
                        case -1: {
                            color = 0x40FF0000;
                        }
                    }
                    if (this.renderType == 2) {
                        color += 0x20000000;
                    }
                    this.drawAroundBlock(new Vector3d((double)toRenderPositions[i].func_177958_n() + 0.5, toRenderPositions[i].func_177956_o(), (double)toRenderPositions[i].func_177952_p() + 0.5), color, 0);
                }
            } else {
                try {
                    Map<BlockPos, Boolean> toRender = this.toRenderTiles;
                    BlockPos[] toRenderPositions = toRender.keySet().toArray(new BlockPos[0]);
                    if (toRenderPositions.length > 50000) {
                        ChatUtils.print("Too many blocks to render!");
                        return;
                    }
                    for (int i = 0; i < toRenderPositions.length; ++i) {
                        if (toRender.get(toRenderPositions[i]).booleanValue()) {
                            this.drawAroundBlock(new Vector3d((double)toRenderPositions[i].func_177958_n() + 0.5, toRenderPositions[i].func_177956_o(), (double)toRenderPositions[i].func_177952_p() + 0.5), -2130731008, 255 - toRenderPositions[i].func_177956_o());
                            continue;
                        }
                        this.drawAroundBlock(new Vector3d((double)toRenderPositions[i].func_177958_n() + 0.5, toRenderPositions[i].func_177956_o(), (double)toRenderPositions[i].func_177952_p() + 0.5), -2048000, 0);
                    }
                }
                catch (ConcurrentModificationException concurrentModificationException) {
                    // empty catch block
                }
            }
        }
    }

    public void drawAroundBlock(Vector3d pos, int color, int my) {
        try {
            Tesselator.ready();
            Tesselator.translate(-this.pos.x, -this.pos.y, -this.pos.z);
            Tesselator.color(color);
            Tesselator.depth(false);
            Tesselator.begin(7);
            Tesselator.put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
            Tesselator.put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
            Tesselator.put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
            Tesselator.put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
            if (this.renderType == 0) {
                Tesselator.next();
                Tesselator.put(pos.getX() - 0.5, pos.getY() + (double)my + 1.01, pos.getZ() + 0.5);
                Tesselator.put(pos.getX() + 0.5, pos.getY() + (double)my + 1.01, pos.getZ() + 0.5);
                Tesselator.put(pos.getX() + 0.5, pos.getY() + (double)my + 1.01, pos.getZ() - 0.5);
                Tesselator.put(pos.getX() - 0.5, pos.getY() + (double)my + 1.01, pos.getZ() - 0.5);
                Tesselator.next();
                Tesselator.put(pos.getX() - 0.5, pos.getY() + (double)my + 1.01, pos.getZ() - 0.5);
                Tesselator.put(pos.getX() + 0.5, pos.getY() + (double)my + 1.01, pos.getZ() - 0.5);
                Tesselator.put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
                Tesselator.put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
                Tesselator.next();
                Tesselator.put(pos.getX() - 0.5, pos.getY() + (double)my + 1.01, pos.getZ() + 0.5);
                Tesselator.put(pos.getX() + 0.5, pos.getY() + (double)my + 1.01, pos.getZ() + 0.5);
                Tesselator.put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
                Tesselator.put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
                Tesselator.next();
                Tesselator.put(pos.getX() - 0.5, pos.getY() + (double)my + 1.01, pos.getZ() - 0.5);
                Tesselator.put(pos.getX() - 0.5, pos.getY() + (double)my + 1.01, pos.getZ() + 0.5);
                Tesselator.put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
                Tesselator.put(pos.getX() - 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
                Tesselator.next();
                Tesselator.put(pos.getX() + 0.5, pos.getY() + (double)my + 1.01, pos.getZ() - 0.5);
                Tesselator.put(pos.getX() + 0.5, pos.getY() + (double)my + 1.01, pos.getZ() + 0.5);
                Tesselator.put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() + 0.5);
                Tesselator.put(pos.getX() + 0.5, pos.getY() - 0.01, pos.getZ() - 0.5);
            }
            Tesselator.end();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }

    static {
        disableCheck.add(Blocks.GLOWSTONE);
        disableCheck.add(Blocks.LOG);
        disableCheck.add((Block)Blocks.LEAVES);
        disableCheck.add(Blocks.LOG2);
        disableCheck.add((Block)Blocks.LEAVES2);
        disableCheck.add(Blocks.COAL_ORE);
        disableCheck.add(Blocks.IRON_ORE);
        disableCheck.add(Blocks.GOLD_ORE);
        disableCheck.add(Blocks.LAPIS_ORE);
        disableCheck.add(Blocks.EMERALD_ORE);
        disableCheck.add(Blocks.DIAMOND_ORE);
        disableCheck.add((Block)Blocks.TALLGRASS);
        disableCheck.add((Block)Blocks.DOUBLE_PLANT);
        disableCheck.add(Blocks.VINE);
        disableCheck.add((Block)Blocks.YELLOW_FLOWER);
        disableCheck.add((Block)Blocks.RED_FLOWER);
        disableCheck.add((Block)Blocks.BROWN_MUSHROOM);
        disableCheck.add((Block)Blocks.RED_MUSHROOM);
        disableCheck.add(Blocks.BROWN_MUSHROOM_BLOCK);
        disableCheck.add(Blocks.RED_MUSHROOM_BLOCK);
        disableCheck.add((Block)Blocks.FIRE);
        disableCheck.add((Block)Blocks.DEADBUSH);
    }
}
